#!/usr/bin/env python3
"""
Web Pentesting MCP Server - Educational security testing tools for authorized environments
"""
import os
import sys
import logging
import subprocess
import re
from mcp.server.fastmcp import FastMCP

# Configure logging to stderr
logging.basicConfig(
    level=logging.INFO,
    format='%(asctime)s - %(name)s - %(levelname)s - %(message)s',
    stream=sys.stderr
)
logger = logging.getLogger("pentest-server")

# Initialize MCP server
mcp = FastMCP("pentest")

# Configuration
MAX_SCAN_TIMEOUT = 300
TARGET_WHITELIST = os.environ.get("PENTEST_TARGET_WHITELIST", "")

# === UTILITY FUNCTIONS ===

def sanitize_target(target: str) -> str:
    """Sanitize and validate target input."""
    target = target.strip()
    if not target:
        return ""
    
    # Remove dangerous characters
    target = re.sub(r'[;&|`$<>]', '', target)
    
    # Basic validation for IP or domain
    if not re.match(r'^[a-zA-Z0-9.-]+$', target.replace('/', '').replace(':', '')):
        return ""
    
    return target

def run_command(cmd, timeout=MAX_SCAN_TIMEOUT):
    """Execute command safely and return results."""
    try:
        result = subprocess.run(
            cmd,
            capture_output=True,
            text=True,
            timeout=timeout,
            shell=False
        )
        return result.returncode, result.stdout, result.stderr
    except subprocess.TimeoutExpired:
        return -1, "", "‚è±Ô∏è Command timed out"
    except Exception as e:
        return -1, "", str(e)

# === MCP TOOLS ===

@mcp.tool()
async def nmap_scan(target: str = "", scan_type: str = "basic", ports: str = "") -> str:
    """Perform network port scanning on target host using nmap with various scan types."""
    logger.info(f"Executing nmap_scan on {target}")
    
    target = sanitize_target(target)
    if not target:
        return "‚ùå Error: Valid target IP or hostname is required"
    
    scan_type = scan_type.strip().lower()
    
    # Build nmap command based on scan type
    if scan_type == "basic":
        cmd = ["nmap", "-sV", target]
    elif scan_type == "quick":
        cmd = ["nmap", "-F", target]
    elif scan_type == "full":
        cmd = ["nmap", "-p-", target]
    elif scan_type == "stealth":
        cmd = ["nmap", "-sS", "-p-", target]
    elif scan_type == "udp":
        cmd = ["nmap", "-sU", "--top-ports", "100", target]
    else:
        cmd = ["nmap", "-sV", target]
    
    # Add custom ports if specified
    if ports.strip():
        ports_clean = re.sub(r'[^0-9,-]', '', ports.strip())
        if ports_clean:
            cmd.extend(["-p", ports_clean])
    
    returncode, stdout, stderr = run_command(cmd)
    
    if returncode == 0:
        return f"‚úÖ Nmap Scan Results for {target}:\n\n{stdout}"
    else:
        return f"‚ùå Nmap scan failed:\n{stderr}"

@mcp.tool()
async def nikto_scan(target: str = "", ssl: str = "auto") -> str:
    """Scan web server for vulnerabilities and misconfigurations using nikto."""
    logger.info(f"Executing nikto_scan on {target}")
    
    target = sanitize_target(target)
    if not target:
        return "‚ùå Error: Valid target URL or hostname is required"
    
    # Add http:// if not present
    if not target.startswith(('http://', 'https://')):
        if ssl.strip().lower() == "yes":
            target = f"https://{target}"
        else:
            target = f"http://{target}"
    
    cmd = ["nikto", "-h", target, "-Format", "txt"]
    
    returncode, stdout, stderr = run_command(cmd, timeout=600)
    
    if returncode == 0 or stdout:
        return f"‚úÖ Nikto Scan Results for {target}:\n\n{stdout}"
    else:
        return f"‚ùå Nikto scan failed:\n{stderr}"

@mcp.tool()
async def dirb_scan(target: str = "", wordlist: str = "common") -> str:
    """Discover hidden directories and files on web server using dirb."""
    logger.info(f"Executing dirb_scan on {target}")
    
    target = sanitize_target(target)
    if not target:
        return "‚ùå Error: Valid target URL is required"
    
    # Add http:// if not present
    if not target.startswith(('http://', 'https://')):
        target = f"http://{target}"
    
    # Select wordlist
    if wordlist.strip().lower() == "big":
        wordlist_path = "/usr/share/dirb/wordlists/big.txt"
    else:
        wordlist_path = "/usr/share/dirb/wordlists/common.txt"
    
    cmd = ["dirb", target, wordlist_path, "-S", "-r"]
    
    returncode, stdout, stderr = run_command(cmd, timeout=600)
    
    if returncode == 0 or stdout:
        return f"‚úÖ Dirb Scan Results for {target}:\n\n{stdout}"
    else:
        return f"‚ùå Dirb scan failed:\n{stderr}"

@mcp.tool()
async def wpscan_scan(target: str = "", enumerate: str = "basic") -> str:
    """Scan WordPress site for vulnerabilities, plugins, themes, and users using wpscan."""
    logger.info(f"Executing wpscan_scan on {target}")
    
    target = sanitize_target(target)
    if not target:
        return "‚ùå Error: Valid WordPress site URL is required"
    
    # Add http:// if not present
    if not target.startswith(('http://', 'https://')):
        target = f"http://{target}"
    
    cmd = ["wpscan", "--url", target, "--no-banner"]
    
    enumerate_type = enumerate.strip().lower()
    if enumerate_type == "plugins":
        cmd.extend(["--enumerate", "p"])
    elif enumerate_type == "themes":
        cmd.extend(["--enumerate", "t"])
    elif enumerate_type == "users":
        cmd.extend(["--enumerate", "u"])
    elif enumerate_type == "all":
        cmd.extend(["--enumerate", "vp,vt,u"])
    
    returncode, stdout, stderr = run_command(cmd, timeout=600)
    
    if returncode == 0 or stdout:
        return f"‚úÖ WPScan Results for {target}:\n\n{stdout}"
    else:
        return f"‚ùå WPScan failed:\n{stderr}"

@mcp.tool()
async def searchsploit_search(keyword: str = "", exact: str = "no") -> str:
    """Search exploit database for known vulnerabilities and exploits using searchsploit."""
    logger.info(f"Executing searchsploit_search for {keyword}")
    
    if not keyword.strip():
        return "‚ùå Error: Search keyword is required"
    
    keyword_clean = re.sub(r'[;&|`$<>]', '', keyword.strip())
    
    if exact.strip().lower() == "yes":
        cmd = ["searchsploit", "-t", keyword_clean]
    else:
        cmd = ["searchsploit", keyword_clean]
    
    returncode, stdout, stderr = run_command(cmd, timeout=30)
    
    if returncode == 0:
        return f"üîç Searchsploit Results for '{keyword_clean}':\n\n{stdout}"
    else:
        return f"‚ùå Searchsploit search failed:\n{stderr}"

@mcp.tool()
async def whatweb_scan(target: str = "", aggression: str = "1") -> str:
    """Identify web technologies, CMS, frameworks, and server info using whatweb."""
    logger.info(f"Executing whatweb_scan on {target}")
    
    target = sanitize_target(target)
    if not target:
        return "‚ùå Error: Valid target URL is required"
    
    # Add http:// if not present
    if not target.startswith(('http://', 'https://')):
        target = f"http://{target}"
    
    # Validate aggression level (1-4)
    agg = aggression.strip()
    if agg not in ["1", "2", "3", "4"]:
        agg = "1"
    
    cmd = ["whatweb", "-a", agg, target]
    
    returncode, stdout, stderr = run_command(cmd, timeout=60)
    
    if returncode == 0:
        return f"‚úÖ WhatWeb Results for {target}:\n\n{stdout}"
    else:
        return f"‚ùå WhatWeb scan failed:\n{stderr}"

@mcp.tool()
async def dnsenum_scan(domain: str = "") -> str:
    """Enumerate DNS information including subdomains, MX records, and nameservers using dnsenum."""
    logger.info(f"Executing dnsenum_scan on {domain}")
    
    domain = sanitize_target(domain)
    if not domain:
        return "‚ùå Error: Valid domain name is required"
    
    # Remove http/https if present
    domain = domain.replace('http://', '').replace('https://', '').split('/')[0]
    
    cmd = ["dnsenum", "--noreverse", domain]
    
    returncode, stdout, stderr = run_command(cmd, timeout=120)
    
    if returncode == 0 or stdout:
        return f"‚úÖ DNSenum Results for {domain}:\n\n{stdout}"
    else:
        return f"‚ùå DNSenum scan failed:\n{stderr}"

@mcp.tool()
async def sublist3r_scan(domain: str = "", engines: str = "all") -> str:
    """Discover subdomains using multiple search engines with sublist3r."""
    logger.info(f"Executing sublist3r_scan on {domain}")
    
    domain = sanitize_target(domain)
    if not domain:
        return "‚ùå Error: Valid domain name is required"
    
    # Remove http/https if present
    domain = domain.replace('http://', '').replace('https://', '').split('/')[0]
    
    cmd = ["sublist3r", "-d", domain, "-t", "10"]
    
    returncode, stdout, stderr = run_command(cmd, timeout=180)
    
    if returncode == 0 or stdout:
        return f"‚úÖ Sublist3r Results for {domain}:\n\n{stdout}"
    else:
        return f"‚ùå Sublist3r scan failed:\n{stderr}"

@mcp.tool()
async def gobuster_scan(target: str = "", mode: str = "dir", wordlist: str = "common") -> str:
    """Fast directory and DNS bruteforcing tool using gobuster."""
    logger.info(f"Executing gobuster_scan on {target}")
    
    target = sanitize_target(target)
    if not target:
        return "‚ùå Error: Valid target is required"
    
    mode = mode.strip().lower()
    
    if mode == "dir":
        if not target.startswith(('http://', 'https://')):
            target = f"http://{target}"
        
        if wordlist.strip().lower() == "big":
            wordlist_path = "/usr/share/dirb/wordlists/big.txt"
        else:
            wordlist_path = "/usr/share/dirb/wordlists/common.txt"
        
        cmd = ["gobuster", "dir", "-u", target, "-w", wordlist_path, "-q"]
    elif mode == "dns":
        domain = target.replace('http://', '').replace('https://', '').split('/')[0]
        wordlist_path = "/usr/share/dirb/wordlists/common.txt"
        cmd = ["gobuster", "dns", "-d", domain, "-w", wordlist_path, "-q"]
    else:
        return "‚ùå Error: Invalid mode. Use 'dir' or 'dns'"
    
    returncode, stdout, stderr = run_command(cmd, timeout=600)
    
    if returncode == 0:
        return f"‚úÖ Gobuster Results for {target}:\n\n{stdout}"
    else:
        return f"‚ùå Gobuster scan failed:\n{stderr}"

@mcp.tool()
async def testssl_scan(target: str = "") -> str:
    """Test SSL/TLS security configuration and vulnerabilities using testssl.sh."""
    logger.info(f"Executing testssl_scan on {target}")
    
    target = sanitize_target(target)
    if not target:
        return "‚ùå Error: Valid target hostname or IP is required"
    
    # Remove http/https if present
    target = target.replace('http://', '').replace('https://', '')
    
    cmd = ["testssl.sh", "--quiet", target]
    
    returncode, stdout, stderr = run_command(cmd, timeout=300)
    
    if returncode == 0 or stdout:
        return f"üîí TestSSL Results for {target}:\n\n{stdout}"
    else:
        return f"‚ùå TestSSL scan failed:\n{stderr}"

@mcp.tool()
async def wafw00f_scan(target: str = "") -> str:
    """Detect and fingerprint Web Application Firewall (WAF) using wafw00f."""
    logger.info(f"Executing wafw00f_scan on {target}")
    
    target = sanitize_target(target)
    if not target:
        return "‚ùå Error: Valid target URL is required"
    
    # Add http:// if not present
    if not target.startswith(('http://', 'https://')):
        target = f"http://{target}"
    
    cmd = ["wafw00f", target]
    
    returncode, stdout, stderr = run_command(cmd, timeout=60)
    
    if returncode == 0:
        return f"üõ°Ô∏è Wafw00f Results for {target}:\n\n{stdout}"
    else:
        return f"‚ùå Wafw00f scan failed:\n{stderr}"

# === SERVER STARTUP ===
if __name__ == "__main__":
    logger.info("Starting Web Pentesting MCP server...")
    logger.warning("‚ö†Ô∏è WARNING: This tool is for authorized security testing only!")
    logger.warning("‚ö†Ô∏è Only use on systems you own or have explicit permission to test!")
    
    if TARGET_WHITELIST:
        logger.info(f"Target whitelist configured: {TARGET_WHITELIST}")
    
    try:
        mcp.run(transport='stdio')
    except Exception as e:
        logger.error(f"Server error: {e}", exc_info=True)
        sys.exit(1)
```

## File 4: readme.txt
```
# Web Pentesting MCP Server

A Model Context Protocol (MCP) server that provides ethical hacking and penetration testing tools for authorized security assessments.

## Purpose

This MCP server provides a secure interface for AI assistants to perform web application penetration testing using industry-standard security tools from Kali Linux. This is designed for educational purposes, bug bounty programs, and authorized security testing only.

## ‚ö†Ô∏è LEGAL WARNING

**IMPORTANT**: This tool is for authorized security testing only. You must:
- Have explicit written permission before scanning any target
- Only test systems you own or have authorization to test
- Comply with all applicable laws and regulations
- Use responsibly for educational and legitimate security purposes

Unauthorized use of these tools may be illegal in your jurisdiction.

## Features

### Current Implementation

- **`nmap_scan`** - Network port scanning with multiple scan types (basic, quick, full, stealth, UDP)
- **`nikto_scan`** - Web server vulnerability scanning and misconfiguration detection
- **`dirb_scan`** - Hidden directory and file discovery on web servers
- **`wpscan_scan`** - WordPress vulnerability scanning including plugins, themes, and user enumeration
- **`searchsploit_search`** - Search exploit database for known vulnerabilities
- **`whatweb_scan`** - Web technology fingerprinting and CMS identification
- **`dnsenum_scan`** - DNS enumeration including subdomains and records
- **`sublist3r_scan`** - Subdomain discovery using multiple search engines
- **`gobuster_scan`** - Fast directory and DNS bruteforcing
- **`testssl_scan`** - SSL/TLS configuration testing and vulnerability detection
- **`wafw00f_scan`** - Web Application Firewall detection and fingerprinting

## Prerequisites

- Docker Desktop with MCP Toolkit enabled
- Docker MCP CLI plugin (`docker mcp` command)
- Authorized target systems for testing
- Written permission for any production systems

## Installation

See the step-by-step instructions provided with the files.

## Usage Examples

In Claude Desktop, you can ask:

- "Run a basic nmap scan on 192.168.1.100"
- "Scan example.com with nikto to find vulnerabilities"
- "Use dirb to find hidden directories on http://testsite.local"
- "Check if example.com is running WordPress and enumerate users with wpscan"
- "Search searchsploit for Apache 2.4.49 exploits"
- "Identify web technologies on https://example.com using whatweb"
- "Enumerate DNS records and subdomains for example.com"
- "Find subdomains of example.com using sublist3r"
- "Run gobuster directory scan on http://testsite.local"
- "Test SSL/TLS security of mail.example.com"
- "Check if example.com has a WAF using wafw00f"

## Architecture
```
Claude Desktop -> MCP Gateway -> Pentest MCP Server -> Security Tools"
                                      ‚Üì
                              Kali Linux Container
                            (nmap, nikto, sqlmap, etc.)
```

## Security Considerations

- All tools run in isolated Docker container
- Running as non-root user with minimal capabilities
- Input sanitization to prevent command injection
- Timeouts prevent resource exhaustion
- All operations logged to stderr
- No credentials stored in the container

## Development

### Local Testing
```bash
# Run directly for testing
python3 pentest_server.py

# Test MCP protocol
echo '{"jsonrpc":"2.0","method":"tools/list","id":1}' | python3 pentest_server.py
```

### Adding New Tools

1. Add the function to pentest_server.py
2. Decorate with @mcp.tool()
3. Update the catalog entry with the new tool name
4. Rebuild the Docker image

## Troubleshooting

### Tools Not Appearing

- Verify Docker image built successfully
- Check catalog and registry files
- Ensure Claude Desktop config includes custom catalog
- Restart Claude Desktop

### Permission Errors

- Ensure capabilities are set correctly in Dockerfile
- Check that tools are installed in the Kali container
- Verify non-root user has necessary permissions

### Scan Timeouts

- Adjust MAX_SCAN_TIMEOUT in pentest_server.py
- Use more targeted scans instead of full scans
- Check network connectivity to target

## Best Practices

1. Always obtain written authorization before testing
2. Start with non-intrusive scans (nmap basic, whatweb)
3. Document all testing activities
4. Respect rate limits and avoid DoS conditions
5. Only test during approved time windows
6. Report findings responsibly

## License

MIT License - Use responsibly and ethically

## Disclaimer

The authors and contributors are not responsible for misuse of this tool. Users are solely responsible for ensuring their use complies with all applicable laws and regulations.
